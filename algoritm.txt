классы:
MainClass - Основной класс, содержит pointers на Servers, собирает проект в целое
Logger - статик класс записывает логи в папку logs
ConfParser - статик класс. Парсит конфиг файл.
Servers - обычный класс. Содержит map <sockFd, class Server> обозначающий все коннекты.
Server  - обычный класс. содержит данные о хосте/порте/запрос/ответ/принадлежность к cgi
Stage - поле внутри класса Server, показывающий текущий статус обработки запроса.
                        // 0-9 - чтение запроса
                            // 0 - только создан / закончил с предыдущим
                            // 1 - chunked запрос, ожидаем очередной chunk //выясняем в парсере
                            // 2 - не весь запрос считан //выясняем в парсере
                            // 3 - чанк не полный
                            // 4 - после считки запроса что-то осталось в string
                            // 5 - запрос считан полносью
                        // 10-19 - отправка ответа клиенту
                            //10 - первичная отправка
                            //11 - отправка очередного чанка
                            //12 - отправка последнего чанка
                        // 20-29 - коммуникация с CGI 
                            //20 - первичная работа с CGI(создание PIPES / CGI)
                            //21 - форк + запуск скрипта
                            //22 - ожидаем ответ скрипта(+ таймер на досрочный выход)
                            //23 - читаем ответ из PipeInBack
                            //24 - отправляем запрос в PipeOutForward
                            //25 - CGI chunked response (из пайпа считано не все) первичка
                            //26 - CGI chunked response очередной
                            //27 - ответ считан полностью после чанка
                            //28 - ответ считан полностью
                            //29 - CGI failed
                        // 30-39 - обработка запроса
                            //30 - запрос только считан
                            //39 - ошибка обработки
                            //подготовка ответа
                        // 40-49 - работа с files
                            //40 - нужно открыть файл
                            //41 - нужно считать данные из файла. 
                                если весь файл поместился в 1024 байт -  ответ content length + Закрываем файл
                                                                else - ответ chunked
                            //42 -  нужно считать очередной chunk из файла
                                                    остаток поместился в 1024 - докидываем в конец нулевой чанк + Закрываем файл
                            //43 - ответ считан полностью
                            //49 - ошибка чтения/записи/отрытия файла
                        //50-59 - parsing requests
                            //	50 - start
							//	51 - start string was fully parsed
							//	52 - headers was fully parsed
							//	53 - body was fully parsed
							//	59 - error
                        // 99 - runtime error

алгоритм:
1. Парсим конфиг файл, создаем слушающие фд для кождого хоста:порта записываем в Servers::map
    пары fd + объект класса Server. Для каждого сервера выделяем память 
    из кучи внутри Servers и чистим в деструкторе.
    Для каждого Server * создаем список t_serv отвечающий за конфиг сервера с именем.
    Для каждого листа в списке t_serv создаем список t_loc отвечающий за параметры location.

2. Запускаем mainloop
    2.0 чистим readset и writeset
    2.1 в зависимости от stage добавляем fd в readset/writeset
        2.1.1 идем по всем используемым подключениям проверяем stage
            2.1.1.1 stage 0/1 - добавляем fdKey в readset
                    stage 10/11/12 - добавляем fdKey в writeset
                    stage 20 - добавляем fdPipeOut в writeset
                    stage 23 - добавляем fdPipeIN в readset
            2.1.1.2 Считаем maxFd
        2.1.2 идем по всем слушающим fd и добавляем в readset, проверяем не нужно ли поменять maxFd
SELECT
    2.2 идем циклом по слушающим fd:
        2.2.1 если в readset - добавляем подключение + клонируем server
    2.3 идем циклом по используемым fd:
        2.3.1 если fdKey в readset:
            2.3.1.1 если resRecv == -1 проверяем stage:
                        // 0/1 Закрываем connection
            2.3.1.2 если resRecv == 0 проверяем stage:
                        // 0 - Закрываем connection
                        // 1 - Закрываем если таймаут
            2.3.1.3 если resRecv > 0 проверяем stage:
                        // 0 - читаем запрос дописываем к стринге запроса
                        // 1 - добавляем чанк к запросу, если чанк последний (==0) - переходим к обработке запроса
        2.3.2 если fdPipeIN в readset смотрим stage
                        // 22 - записываем ответ (// 22 - записываем в ответ ошибку 5XX/отдаем стандартную ошибку html)
        2.3.3 если fdKey в writeset:
            2.3.3.1 отправляем и проверяем результат
            2.3.3.2 <0 - close connection
            2.3.3.3 <len - ресайз ответа
            2.3.3.4 выствляем stage 1;
        2.3.4 если fdPipeOut в writeset смотрим stage, если есть что отправить - отправляем
        2.4 проверяем для всех используемых connection timeout и закрывают то что не обновлялось


